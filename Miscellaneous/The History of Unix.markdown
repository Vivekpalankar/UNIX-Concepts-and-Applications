## The History of Unix

In the late 1960s, a project was under-way at the Massachusetts Institute of Technology (MIT) to improve the state-of-the-art in timesharing software. Along with MIT, Bell Laboratories and General Electric (GE was once a mainframe computer manufacturer) were collaborators in the venture. But Multics, as the system was christened, was too big and slow - an overdesigned behemoth of the software world. So Bell Labs pulled their people out of the project, which left MIT and GE to develop the system further on their own. (They did, and Honeywell, who later bought GE's computer operation, still sells Multics.) Unfortunately, that left Ken Thompson, a computer scientist at Bell Labs, without any hardware to run his video game.

Thompson had written a simulation of the solar system, called Space Travel, which ran on the Multics system on a timesharing terminal. The loss of Multics was the impetus he needed to find hardware he could use exclusively. He gained access to a Digital Equipment Corporation (DEC) PDP-7, complete with a video display that would enhance Space Travel tremendously. While Thompson was rewriting Space Travel for the PDP-7, he began experimenting with some ideas he had for a new type of file system. Working in PDP-7 assembly language, he soon had his file system running with some utility programs and a central core (or kernel) that together made a rudimentary operating system. Here was a system designed by one man for the sole purpose of making his own software-development work easier. Unix was thought to be a good name for it - the Uni (one) was a word play on the Multi (many) of Multics.

Unix came to the attention of others at Bell Labs, including Dennis Ritchie, another systems software designer. Together, Ritchie and Thompson enhanced Unix, adding some word-processing facilities in response to hints that another department needed a word-processor. This earned the designers enough funding for a PDP-11 minicomputer, a more modern and reliable machine than the PDP-7. Eventually, other departments bought PDP-11s and chose to use Unix for the software base rather than DEC's own operating systems.

But Thompson, dissatisfied as he was with other operating systems, also felt that programming languages could be improved. FORTRAN was tried and discarded. He then worked for a while on BCPL (Basic Combined Programming Language), which was a simplification of CPL, itself a simplification of the Algol 60 language (today, we would call Algol 60 a Pascal like language). Thompson condensed BCPL down to is most basic features. The interpreted language that resulted he named simply B. Ritchie then took the best parts of B, reworked them until he had a language that was simple and elegant, added data structures, and called it C. Ritchie and Thompson both felt this was a language suitable for systems programming - one that allowed a programmer to express concepts clearly without being tied to one machine's architecture, and yet was efficient enough so that assembly language would not be needed for speed.

### Getting a Handle on Portability

Unix was written in C in 1973, whereupon Ritchie and Thompson realized that because C was a relatively high-level language, compilers could be written on other computers to give them C capability too. And because Unix was written in C, theoretically, Unix could then be moved to these other machines. The experiment was tried in 1977 with an Interdata 8/32, a 32-bit minicomputer that was as unlike the PDP-11 as possible. All code specific to the PDP-11 was taken out of the kernel and rewritten to make it easy to transport Unix. After the Interdata test, they moved Unix to an IBM/370 mainframe. With each trial they learned more about C, Unix and portability in general.

Until Unix, operating systems were written exclusively in assembly language. This long, error-prone process seemed the only one appropriate to an industry that considered machine efficiency to be more essential than human efficiency because computers were more expensive in dollars and cents than human labor. Compared to other languages, assembly language allows that fastest execution of instructions and takes up the least memory space; therefore, programs as important as operating systems could only be written in assembly language. Who cared if a programmer or two were crazy trying to understand it? What was the difference if it took a long time to write and three times as long to debug?

Ritchie and Thompson saw that a software designer's environment was more important, in the long run, than that of the computer; computer hardware tends to get cheaper and faster, while the cost of labor in both economical and emotional terms tends to go up. This last is especially true when the software tools at hand are not appropriate for the job. Unix forever broke the notion that a system had to be written in assembly language and therefore tied to a specific computer design, word size, or architecture. For the first time, an entire programming environment, including file system, kernel, applications packages, utility programs, and user interface, could be moved to an entirely different type of machine.

Think about that for a moment. Look at the CP/M 2.2 operating system. CP/M has gained immense popularity; it runs on computers made by literally hundreds of different manufacturers and supports many different languages and applications packages. Why is it so popular with computer makers? CP/M is portable to many different hardware configurations. The catch is that the systems must use a microprocessor that runs 8080 assembly code.

In comparison, you can now run Unix or Unix-compatible systems on computers based on any of these processors: 8080, Z80, 8086, 8088, Z8000, 68000, 16032, LSI-11, PDP-11, VAX, HP-9000, PerkinElmer, Gould S.E.L., BBN C-Machine, IBM Series/1, and IBM/370. Typical hardware configurations range from $5000 to considerably more. A program correctly written in C for any of these machines will run on any other one, needing only to be physically moved and recompiled. No doubt you can see why so many software houses have suddenly discovered Unix. By using C and Unix, they can expand their potential customer base tremendously with little trouble - one user manual, one customer group, one version of source code. The net result can benefit everyone with better, more widely used software at lower price.

---

_Source: Byte Magazine Volume 08 Number 08 - The C Language_
